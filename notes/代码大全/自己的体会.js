自己的一些体会
P80
噢，对对对，我自己写的时候老是想着，怎么能写简洁，但是，这还没解决就想简洁，违背自然规律啊。。本末倒置了。。况且，有些情况就是很复杂的，比如最近写的那个判断两个对象相等的函数，要考虑到键值对的值里是数组或者又是对象，所以里头就是有比较多的 if /else if。
还有之前写的表单验证逻辑，就是有这么多的情况需要判断，可能顶多就只能用表驱动法抽出来，我晚点抽出来看看，看抽出来之后，容不容易理解了。。

P94
隐藏设计决策对于减少“改动所影响的代码量”而言是至关重要的
需要隐藏的：创建新 Id，以及 id 的类型，都需要隐藏。
用一个函数封装起来，比如 newId() 这样的，把新建 id 的方法或者 id 是什么类型都藏到函数里。
而不是暴露出来，导致一改的时候，到处都要改。。

P102
语义耦合的例子 看着就不舒服，自己写的时候也该尽力去避免。

P103
每个人都曾经自己写过几次快速排序算法，但你自己写的版本一写就对的可能性有多少呢？与之相似，大量的设计问题都与就有问题相关

P105
构造分层结构，大概需要合理运用 思维导图（试试百度脑图）

P118
本章前面的图 5-6 在 P88

P136
“因为它支持多态”，对多态的解释在 P91

P139
这里提到封装。又提到 5.3 里的论述，发现倒回去看关于封装的比喻又有新的体会，怪不得大牛把代码大全这本书看了四遍，果然，该多翻

P139
这里说到“某个子程序的可访问性应该设为公用（public）、私用（private）、抑或受保护（protected）时”，看到这个 protected 想起之前在 mdn 看了个啥东西是 protected 的，一时记不起来是啥了。。。而且红皮书上也有的。。啊，是啥啊。。忘记了。。看完代码大全再重新看红皮书，应该能想起来。。

P139
尽可能地限制类和成员的可访问性
这里的意思大概是，1、如果你能确定保证抽象的一致性的话，就可以暴露某个子程序；2、但如果你不确定，那多隐藏比少隐藏好

P140
代码里讲了暴露类内部细节是怎么样的，隐藏又是怎么样的

P141
隐藏细节、不对使用者做假设（大概就是不要去考虑边边角角的东西）、管理复杂度、抽象一致性、不要为了贪图一时方便（而降低代码可读性/而违反抽象一致性/而破坏封装/而暴露细节）、注意语义封装和语法封装

P143
这里建议要把数据声明为 private 而不是 protected；
噢，原来高耦合总是发生在抽象不严谨和封装性遭到破坏的时候啊。。那言下之意还是，必须保证好封装性和抽象。。
这里又提到黑盒子。。前面的内容也看到过，当时就想起 sicp 那个视频了。。

P143
在万不得已时通过 private 继承来实现“有一个”的关系。这段比较难懂，但大概猜测，意思是，A 对象为了包含 B 对象，就通过 private 继承，让 A 对象所在的类能访问 B 对象所在的类的 protected 函数方法和数据（但我这个理解有可能是错的）

P151
这里提到深拷贝和浅拷贝，之前接触过这个，但是一直不太理解， mark 一下，今晚回去看看 lodash 对这个的实现。

P162
给了个 C++ 低质量的子程序的例子，作者让先自己看看它有什么不妥。说最少有 10 个。那我在看他揭晓之前，我先自己试试看看能不能分辨出来。
第一，不知道 C++ 要求的代码格式是怎么样的，但这个格式看得头疼
第二，这些变量命名也看得头疼，不知道是什么意思
第三，定义了一堆变量在最上面，我觉得应该要用的时候再定义（噢，看了作者写的，知道那些是参数，我傻了，确实是参数）
第四，if / else if 太多了，既然都是 expenseType，那该用表驱动法抽成对象
第五，什么东西都写到一起了，里头有些步骤也该另外抽成函数，for 循环，if else 这些都该用函数封装起来
第六，for 循环里的 i，为什么是在外面声明？ C++ 的规定么？

作者的答案：
1、这个子程序命名糟糕，HandleStuff 不知道是拿来干啥的。
2、没有文档
3、布局不好，整个布局没有任何逻辑提示
4、inputRec 的值被改了，如果是输入变量就不该被改（C++ 的知识吧）
5、有个全局变量 i，corpExpense 用到，profit 也用到
6、没有单一目的
7、没有防范错误数据，比如分母为 0
8、用了若干神秘数值，100、4.0、12、2、3
9、定义了的参数未使用，screenX 和 screenY
10、参数传递有误
11、参数太多了 11个，应该控制在 7 个以内
12、参数顺序混乱，又没有注释
P168
耦合度与内聚性之比高（低内聚，高耦合）
耦合度与内聚性之比低（高内聚，低耦合）

P170
逻辑上的内聚性
噢，我那个表单验证就有这个问题，我一开始还以为用表驱动法来解决呢，原来是这
后文说在某个情况下，这样也是可以的
这里还提到 24.3 会说用多态替代 case

P171
不要仅通过数字来形成不同的子程序名字 举的那个例子，忍不住笑出声，但一想到要是让我遇到了，笑容渐渐消失。。

P173
关于子程序可以有多长的问题，除了这里的论述，
angular 文档也有 - 风格指南 - 组件文件 400 行以内；函数 75 行以内
官网：https://angular.io/guide/styleguide
中文：https://angular.cn/guide/styleguide
（哎，我也看过组件文件几千行、几万行的。。可怕。。难改。。）

P174
参数排列这里，提到按“输入 - 修改 - 输出的顺序排列参数 不要随机地按字母顺序排列”，又忍不住笑出声，跟按数字命名有异曲同工之坑啊。。2333。噢，再细致想想，感觉是要无论是哪个细节都应该考虑到逻辑性，使读代码的人，能快速理解。

P175
当然，如果你总是统一地采用某种排列规则的话，那么为代码的读者考虑，你还是沿用自己的规则为好
这里说明，保持一致性的重要程度更高。不要朝令夕改，让人摸不着头脑。

P176
这里说到的两个弊端，让我觉得，某些情况下，由于 JavaScript 没有枚举，只能用字符串，也产生了类似这样的弊端

P177
这的意思大概就是用一个变量接一下参数，那这个变量变不变，变成咋样，就跟原来传进来的参数无关了。

P184
宏，还是不要用了。。
调用子程序的开销？什么开销？
噢，内联子程序违反了封装原则，那内联子程序还是不要用了。。

P204
这个隔离大概就是之前那个 echarts 的 cleanData
